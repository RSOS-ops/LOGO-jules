<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Text Pool</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #fff; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
            padding: 10px;
            background-color: rgba(0,0,0,0.2);
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            background-color: #444;
            color: #fff;
            border: 1px solid #666;
            border-radius: 8px;
            margin-top: 10px;
            transition: background-color 0.3s, transform 0.1s;
        }
        button:hover {
            background-color: #555;
        }
        button:active {
            transform: scale(0.95);
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="info">
        <h1>Text Pool Demonstration</h1>
        <p>Click the button to display a random word from the pool.</p>
        <button id="changeTextBtn">New Word</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // Basic Scene Setup
        let scene, camera, renderer;
        let textMesh;

        // --- TEXT POOL DEFINITION ---
        // This is the core array containing both ASCII characters and your commands.
        const textPool = [];

        // 1. Populate with ASCII characters (Printable characters from 32 to 126)
        for (let i = 32; i <= 126; i++) {
            textPool.push(String.fromCharCode(i));
        }

        // 2. Populate with the specified list of commands
        const commands = [
            "Command", "FORWARD", "BACK", "RIGHT", "LEFT", "PENUP", "PENDOWN",
            "SETPOS", "SETHEADING", "HOME", "CLEARSCREEN", "CLEAN", "HIDETURTLE",
            "SHOWTURTLE", "PENCOLOR", "BACKGROUND", "WRAP", "FENCE", "WINDOW",
            "SUM", "DIFFERENCE", "PRODUCT", "QUOTIENT", "REMAINDER", "SQRT",
            "RANDOM", "SIN", "COS", "TAN", "ARCTAN", "TO", "END", "REPEAT", "IF",
            "IFELSE", "STOP", "OUTPUT", "MAKE", "WAIT", "GO", "LABEL", "OP",
            "BACKGROUND", "BACK", "CLEARSCREEN", "FORWARD", "HIDETURTLE", "LEFT",
            "PENCOLOR", "PENDOWN", "PENUP", "RIGHT", "SETHEADING", "SHOWTURTLE",
            "SETPOS", "HOME", "CLEAN", "WRAP", "FENCE", "WINDOW", "BG", "BK",
            "CS", "FD", "HT", "LT", "PC", "PD", "PU", "RT", "SETH", "ST", "FD",
            "BK", "RT", "LT", "PU", "PD", "SETH", "CS", "HT", "ST", "PC", "BG"
        ];

        // Use a Set to get unique commands, then spread back into an array
        const uniqueCommands = [...new Set(commands)];
        
        // Add the unique commands to the text pool
        textPool.push(...uniqueCommands);

        // --- THREE.JS INITIALIZATION AND LOGIC ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(5, 10, 15);
            scene.add(pointLight);

            // Initial text creation
            createText();

            // Event Listeners
            document.getElementById('changeTextBtn').addEventListener('click', createText);
            window.addEventListener('resize', onWindowResize, false);

            // Start animation loop
            animate();
        }

        // --- TEXT CREATION FUNCTION ---
        function createText() {
            // If a text mesh already exists, remove it from the scene
            if (textMesh) {
                scene.remove(textMesh);
                textMesh.geometry.dispose();
                textMesh.material.dispose();
            }

            // Get a random word from the pool
            const randomWord = textPool[Math.floor(Math.random() * textPool.length)];

            // Font loading
            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
                const textGeometry = new THREE.TextGeometry(randomWord, {
                    font: font,
                    size: 3,
                    height: 0.5,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.1,
                    bevelSize: 0.1,
                    bevelOffset: 0,
                    bevelSegments: 5
                });

                // Center the text geometry
                textGeometry.computeBoundingBox();
                const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                textGeometry.translate(-0.5 * textWidth, 0, 0);

                // Material
                const textMaterial = new THREE.MeshStandardMaterial({
                    color: 0x00aaff, // A bright blue color
                    metalness: 0.8,
                    roughness: 0.2
                });

                // Mesh
                textMesh = new THREE.Mesh(textGeometry, textMaterial);
                scene.add(textMesh);
            });
        }

        // --- UTILITY FUNCTIONS ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Add a little rotation for visual interest
            if (textMesh) {
                textMesh.rotation.y += 0.005;
            }

            renderer.render(scene, camera);
        }

        // Let's go!
        init();

    </script>
</body>
</html>
